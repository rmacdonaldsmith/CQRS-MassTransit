using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using CQRS.DomainTesting;
using CQRS.Interfaces.Commands;
using CQRS.Interfaces.Events;
using NUnit.Framework;

namespace CQRS.TimeoutService.Tests
{
    public abstract class TimeoutSpecification<TCommand> where TCommand : ICommand
    {
        protected IFakeEventStore EventStore;

        /// <summary>
        /// Setup - these events need to have occured to get our domain object in to a valid initial state
        /// </summary>
        /// <returns></returns>
        public abstract IEnumerable<IEvent> Given(); 

        /// <summary>
        /// The command to apply to the domain object
        /// </summary>
        /// <returns></returns>
        public abstract TCommand When();

        //public abstract Expression<Action<TCommand>> When();

        /// <summary>
        /// The command handler that will initialize the domin object and invoke the command on the domain object
        /// </summary>
        /// <returns></returns>
        public abstract global::CQRS.Interfaces.Commands.Handles<TCommand> OnHandler();

        /// <summary>
        /// The events that we expect to the generated when the command is applied to the domain object
        /// </summary>
        /// <returns></returns>
        public abstract IEnumerable<IEvent> ThenExpectAfterTimeSpan(TimeSpan timeoutPeriod); //the events that we expect to be generated by the SUT

        public abstract Exception ExpectedException();

        public abstract Expression<Predicate<Exception>> ThenException();

        public static IEnumerable<IEvent> NoEvents 
        {
            get { return new IEvent[0]; }
        }

        public static Expression<Predicate<Exception>> NoException
        {
            get { return exception => exception == null; }
        }

        /// <summary>
        /// Tear down and cleanup when the test has finished
        /// </summary>
        public abstract void Finally();

        [Test]
        public void SetUp()
        {
            EventStore = new FakeEventStore(Given());
            var commandHandler = OnHandler();
            List<IEvent> expected = null;
            List<IEvent> produced = null;

            try
            {
                commandHandler.Handle(When());
                expected = ThenExpectAfterTimeSpan(TimeSpan.FromSeconds(10)).ToList();
                produced = EventStore.PeakChanges().ToList();
            }
            catch (Exception exception)
            {
                if (ThenException().Compile()(exception))
                {
                    Assert.Pass();
                }

                if (ExpectedException() == null)
                {
                    Assert.Fail(string.Format("No exception expected but received a {0} exception.", exception.GetType()));
                }

                Assert.Fail(string.Format("Expected a {0} exception but received a {1} exception.",
                                          ExpectedException().GetType(), exception.GetType()));
            }
            finally
            {
                Finally();
            }

            CompareMessages(expected, produced);
        }

        protected void CompareMessages(List<IEvent> expected, List<IEvent> actual)
        {
            if(expected.Count != actual.Count)
            {
                Assert.Fail(String.Format("Expected to receive {0} events but received {1} events.", expected.Count, actual.Count));
            }

            for (int index = 0; index < expected.Count; index++)
            {
                var expectedEvent = expected[index];
                var actualEvent = actual[index];

                if (EventPropertiesAreEqual(actualEvent, expectedEvent, new[] { "ExtensionData" }) == false)
                {
                    Assert.Fail(String.Format("Events at index {0} are not equivalent.", index));
                }
            }
        }

        public static bool EventPropertiesAreEqual(IEvent self, IEvent to, params string[] ignore)
        {
            if (self == null || to == null)
            {
                return false;
            }

            Type selfType = self.GetType();
            if (selfType != to.GetType())
            {
                return false;
            }

            var ignoreList = new List<string>(ignore);
            foreach (var propertyInfo in selfType.GetProperties(BindingFlags.Public | BindingFlags.Instance))
            {
                if (!ignoreList.Contains(propertyInfo.Name))
                {
                    object selfValue = selfType.GetProperty(propertyInfo.Name).GetValue(self, null);
                    object toValue = selfType.GetProperty(propertyInfo.Name).GetValue(to, null);

                    if (selfValue != toValue && (selfValue == null || !selfValue.Equals(toValue)))
                    {
                        return false;
                    }
                }
            }
            return true;
        }
    }
}
